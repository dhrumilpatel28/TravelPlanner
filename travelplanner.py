# -*- coding: utf-8 -*-
"""TravelPlanner.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VZxPK_Eq9v_kU-clJ8IpI6jzrPgjsHex
"""

# importing the dependencies

import pandas as pd
from transformers import pipeline , T5ForConditionalGeneration, T5Tokenizer, Trainer, TrainingArguments
import re
import unicodedata
from datasets import Dataset

# loading the dataset which we want to use while fine tuning

df = pd.read_csv('/content/final_training_data (1).csv')

df.head()

df.columns

# We need to rename this as input and target casue T5 model has this requirement

df = df.rename(columns= {"query" : "input_text", "plan" : "target_text"})

df.columns

# creating the huggingg face dataset

dataset = Dataset.from_pandas(df[['input_text', 'target_text']])
dataset = dataset.train_test_split(test_size= 0.2, seed= 42)

# Loading the tokenizer and model

model = T5ForConditionalGeneration.from_pretrained("t5-small")
tokenizer = T5Tokenizer.from_pretrained("t5-small")

# After loading the tokenizer gotta tokenize the dataset right?

def tokenize_function(examples):
  prefix  = "Generate travel plan: "
  inputs = [prefix + doc for doc in examples['input_text']]

  model_inputs = tokenizer(inputs , max_length= 256 ,truncation = True , padding= 'max_length')

  # Now tokenizing the target text
  labels = tokenizer(examples['target_text'],  max_length= 512 ,truncation = True, padding= 'max_length')

  model_inputs['labels'] = labels['input_ids']

  return model_inputs


tokenized_datasets = dataset.map(tokenize_function, batched = True)

# now lets set the training arguments

training_args = TrainingArguments(
    output_dir="./results",
    num_train_epochs=10,  # Increased epochs for better learning on the new data
    per_device_train_batch_size=4, # Smaller batch size for potentially longer sequences
    per_device_eval_batch_size=4,
    warmup_steps=500,
    weight_decay=0.01,
    logging_dir="./logs",
    logging_steps=100,
    eval_strategy="epoch",
    save_strategy="epoch",
    load_best_model_at_end=True,
    report_to="none",
)

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["test"],
)

# Start the training
trainer.train()

# save the model and tokenizer after the training

trainer.save_model('./t5-travel-planner-finetuned')
tokenizer.save_pretrained(final_model_path)

# now lets load the transformers pipeline and original dataset

df = pd.read_csv('/content/cleaned_dataset_travelPlanner.csv')
planner = pipeline('text2text-generation', model = './t5-travel-planner-finetuned', tokenizer = './t5-travel-planner-finetuned' )

# now lets do some normalization for the text

def normalize(s):
  if pd.isnull(s):
    return ""

  s = str(s)
  s = unicodedata.normalize("NFKD", s).encode('ascii', 'ignore').decode('utf-8')
  return s.strip().lower()

# taking user query as the input

query = input("Enter the travel plan query: ")

prefix = 'Generate the travel plan: '
prefixed_query = prefix + query
generated_plan = planner(prefixed_query, max_length = 512, num_beams = 5 , early_stopping = True)[0]['generated_text'] # This will generate the raw plan using the model which is not used in our project

print("The generated Travel plan from the model is : ", generated_plan)

# Now we will actully extract important details from query

# for the city match
city_match = re.search(r'to\s+([\w\s]+?)\s+for', query, re.IGNORECASE)
destination_city = city_match.group(1).strip() if city_match else 'goa'
normalized_city = normalize(destination_city)

# for the day match
days_match = re.search(r'(\d+)\s+days?', query, re.IGNORECASE)
num_days = int(days_match.group(1)) if days_match else 3

# for the budget match
budget_match = re.search(r'budget of\s+(Rs.)*\s*([\d,]+)',query, re.IGNORECASE)
total_budget = int(budget_match.group(1)) if budget_match else 15000

# Budget Allocation logic

hotel_budget = total_budget * 0.4
attraction_budget = total_budget * 0.3
food_budget = total_budget * 0.3

hotel_budget_per_night = hotel_budget / num_days
attraction_budget_per_day = attraction_budget / num_days
food_budget_per_meal = (food_budget / num_days) / 3 # Assuming 3 meals per day

# cleaning the dataset for the calculation

df['price'] = pd.to_numeric(df['price'], errors= "coerce")
df['rating'] = pd.to_numeric(df['rating'],errors = 'coerce')
df.dropna(subset=['price', 'rating', 'city', 'category', 'name'],inplace = True)

city_df = df[df['city'].apply(normalize).str.contains(normalized_city, na = False)]
hotel = city_df[(city_df['category'] == 'hotel') & (city_df['price'] <= hotel_budget_per_night)].sort_values('rating', ascending = False).head(5)
attractions = city_df[(city_df['category'] == 'attraction') & (city_df['price'] <= attraction_budget_per_day)].sort_values('rating', ascending= False).head(5)
restaurant = city_df[(city_df['category'] == 'restaurant') & (city_df['price'] <= food_budget_per_meal)].sort_values('rating', ascending = False).head(5)

# Displaying the Travel Plan

print("Your travel query is : ", query)

print("\n    Your complete Travel Plan")
print(f"\nDestination: {destination_city} (number of days: {num_days}, budget: {total_budget})")

print(f"  hotel budget day wise: ~{hotel_budget_per_night:,.0f}/night")
print(f"  food budget day wise: ~{food_budget_per_meal:,.0f}/meal")
print(f"  attraction budget day wise: ~{attraction_budget_per_day:,.0f}/day")

# Displaying Hotels
if not hotel.empty:
  print(" \nThe suggested hotels (within the budget): ")
  for _, row in hotel.iterrows():
    print(f" - {row['name']} | Rating - {row['rating']} | cost/night: Rs{row['price']:,.0f}")
else:
  print("No hotel found in the given budget")


# Displaying restaurant
if not restaurant.empty:
  print(" \nThe suggested restaurant (within the budget): ")
  for _, row in restaurant.iterrows():
    print(f"  - {row['name']} | Rating - {row['rating']} | cost: Rs{row['price']:,.0f} | Cuisine: {row['cuisine_or_amenities']}")
else:
  print("No restaurant found in the given budget")

# Display Attractions
if not attractions.empty:
    print("\n Top Attractions (within budget):")
    for _, row in attractions.iterrows():
        print(f"  - {row['name']} | Rating: {row['rating']} | Entry Fee: â‚¹{row['price']:,.0f}")
else:
    print("\n No attractions found within budget.")

